# PRP Part 2: Notifications Module & Order Expiration Scheduler

<!-- EXPAND_BEFORE_IMPLEMENTING: This part requires full technical detail expansion -->

**Feature:** Event-Driven Order Lifecycle & Notifications
**Part Focus:** Notifications audit trail + scheduled order expiration
**Created:** 2026-01-18
**Confidence Score:** 9/10

---

## Executive Summary

This PRP covers:
1. Database migration for notifications table
2. Notification entity, repository, and service
3. OrderExpirationJob scheduler
4. OrderRepository query for stale orders
5. Integration tests for notifications and expiration

**Files Covered in This Part:** 8 files

---

## 1. Files to Create/Modify

### 1.1 New Files

| # | File Path | Purpose |
|---|-----------|---------|
| 1 | `src/main/resources/db/migration/V3__create_notifications_table.sql` | Flyway migration |
| 2 | `src/main/java/com/gpustore/notification/Notification.java` | Entity extending BaseEntity |
| 3 | `src/main/java/com/gpustore/notification/NotificationType.java` | Enum: EMAIL, SYSTEM_ALERT |
| 4 | `src/main/java/com/gpustore/notification/NotificationRepository.java` | JPA Repository |
| 5 | `src/main/java/com/gpustore/notification/NotificationService.java` | RabbitMQ listener, persists notifications |
| 6 | `src/main/java/com/gpustore/order/OrderExpirationJob.java` | Scheduled job (every 60s) |
| 7 | `src/test/java/com/gpustore/notification/NotificationServiceIT.java` | Integration tests |
| 8 | `src/test/java/com/gpustore/order/OrderExpirationJobIT.java` | Integration tests |

### 1.2 Modified Files

| # | File Path | Modification |
|---|-----------|--------------|
| 1 | `src/main/java/com/gpustore/order/OrderRepository.java` | Add `findByStatusAndUpdatedAtBefore()` query |

---

## 2. Implementation Details

### 2.1 Database Migration

**File:** `src/main/resources/db/migration/V3__create_notifications_table.sql`

```sql
-- Notifications table for audit trail
CREATE TABLE notifications (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL CHECK (type IN ('EMAIL', 'SYSTEM_ALERT')),
    message TEXT NOT NULL,
    sent_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for common queries
CREATE INDEX idx_notifications_order_id ON notifications(order_id);
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_notifications_sent_at ON notifications(sent_at);

-- Index for order expiration query (status + updated_at)
CREATE INDEX idx_orders_status_updated_at ON orders(status, updated_at);
```

### 2.2 Notification Entity

**File:** `src/main/java/com/gpustore/notification/Notification.java`

```java
package com.gpustore.notification;

import com.gpustore.common.BaseEntity;
import com.gpustore.order.Order;
import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * Entity representing a notification/audit log entry.
 * Created when orders reach terminal states (COMPLETED, EXPIRED).
 */
@Entity
@Table(name = "notifications")
public class Notification extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private NotificationType type;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String message;

    @Column(name = "sent_at", nullable = false)
    private LocalDateTime sentAt;

    // Constructors
    protected Notification() {}

    public Notification(Order order, NotificationType type, String message) {
        this.order = order;
        this.type = type;
        this.message = message;
        this.sentAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Order getOrder() { return order; }
    public void setOrder(Order order) { this.order = order; }

    public NotificationType getType() { return type; }
    public void setType(NotificationType type) { this.type = type; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public LocalDateTime getSentAt() { return sentAt; }
    public void setSentAt(LocalDateTime sentAt) { this.sentAt = sentAt; }
}
```

### 2.3 NotificationType Enum

**File:** `src/main/java/com/gpustore/notification/NotificationType.java`

```java
package com.gpustore.notification;

/**
 * Types of notifications generated by the system.
 */
public enum NotificationType {
    /** Simulated email notification for order completion */
    EMAIL,
    /** System alert for order expiration or errors */
    SYSTEM_ALERT
}
```

### 2.4 NotificationRepository

**File:** `src/main/java/com/gpustore/notification/NotificationRepository.java`

```java
package com.gpustore.notification;

import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

/**
 * Repository for Notification entities.
 */
public interface NotificationRepository extends JpaRepository<Notification, Long> {

    List<Notification> findByOrderId(Long orderId);

    List<Notification> findByType(NotificationType type);
}
```

### 2.5 NotificationService

**File:** `src/main/java/com/gpustore/notification/NotificationService.java`

```java
package com.gpustore.notification;

import com.gpustore.common.exception.ResourceNotFoundException;
import com.gpustore.config.RabbitMqConfig;
import com.gpustore.event.OrderCompletedEvent;
import com.gpustore.event.OrderExpiredEvent;
import com.gpustore.order.Order;
import com.gpustore.order.OrderRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service that listens to order events and creates audit notifications.
 */
@Service
public class NotificationService {

    private static final Logger log = LoggerFactory.getLogger(NotificationService.class);

    private final NotificationRepository notificationRepository;
    private final OrderRepository orderRepository;

    public NotificationService(NotificationRepository notificationRepository,
                               OrderRepository orderRepository) {
        this.notificationRepository = notificationRepository;
        this.orderRepository = orderRepository;
    }

    /**
     * Handles order completed events - creates EMAIL notification.
     */
    @RabbitListener(queues = RabbitMqConfig.COMPLETED_QUEUE)
    @Transactional
    public void handleOrderCompleted(OrderCompletedEvent event) {
        log.info("Handling order completed event: orderId={}", event.orderId());

        Order order = orderRepository.findById(event.orderId())
                .orElseThrow(() -> new ResourceNotFoundException("Order", event.orderId()));

        String message = String.format(
                "Order #%d completed successfully. Total amount: $%.2f. " +
                "Thank you for your purchase!",
                event.orderId(), event.total()
        );

        Notification notification = new Notification(order, NotificationType.EMAIL, message);
        notificationRepository.save(notification);

        // Simulate sending email (log only)
        log.info("EMAIL NOTIFICATION: To user {} - {}", event.userId(), message);
    }

    /**
     * Handles order expired events - creates SYSTEM_ALERT notification.
     */
    @RabbitListener(queues = RabbitMqConfig.EXPIRED_QUEUE)
    @Transactional
    public void handleOrderExpired(OrderExpiredEvent event) {
        log.info("Handling order expired event: orderId={}, reason={}",
                event.orderId(), event.reason());

        Order order = orderRepository.findById(event.orderId())
                .orElseThrow(() -> new ResourceNotFoundException("Order", event.orderId()));

        String message = String.format(
                "Order #%d has expired. Reason: %s. " +
                "Please contact support if you believe this is an error.",
                event.orderId(), event.reason()
        );

        Notification notification = new Notification(order, NotificationType.SYSTEM_ALERT, message);
        notificationRepository.save(notification);

        // Log system alert
        log.warn("SYSTEM ALERT: Order {} expired - {}", event.orderId(), event.reason());
    }
}
```

### 2.6 OrderExpirationJob

**File:** `src/main/java/com/gpustore/order/OrderExpirationJob.java`

```java
package com.gpustore.order;

import com.gpustore.config.RabbitMqConfig;
import com.gpustore.event.EventBus;
import com.gpustore.event.OrderExpiredEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Scheduled job that expires orders stuck in PROCESSING state.
 *
 * <p>Runs every 60 seconds and marks orders as EXPIRED if they have been
 * in PROCESSING state for more than 10 minutes.</p>
 */
@Component
public class OrderExpirationJob {

    private static final Logger log = LoggerFactory.getLogger(OrderExpirationJob.class);
    private static final int EXPIRATION_MINUTES = 10;

    private final OrderRepository orderRepository;
    private final EventBus eventBus;

    public OrderExpirationJob(OrderRepository orderRepository, EventBus eventBus) {
        this.orderRepository = orderRepository;
        this.eventBus = eventBus;
    }

    /**
     * Finds and expires stale orders.
     * Runs every 60 seconds.
     */
    @Scheduled(fixedRate = 60000)
    @Transactional
    public void expireStaleOrders() {
        LocalDateTime cutoff = LocalDateTime.now().minusMinutes(EXPIRATION_MINUTES);

        List<Order> staleOrders = orderRepository.findByStatusAndUpdatedAtBefore(
                OrderStatus.PROCESSING, cutoff
        );

        if (staleOrders.isEmpty()) {
            log.debug("No stale orders found for expiration");
            return;
        }

        log.info("Found {} stale orders to expire", staleOrders.size());

        for (Order order : staleOrders) {
            expireOrder(order);
        }
    }

    private void expireOrder(Order order) {
        order.setStatus(OrderStatus.EXPIRED);
        orderRepository.save(order);

        eventBus.publish(RabbitMqConfig.ROUTING_KEY_EXPIRED, new OrderExpiredEvent(
                order.getId(),
                order.getUser().getId(),
                "Processing timeout exceeded " + EXPIRATION_MINUTES + " minutes",
                LocalDateTime.now()
        ));

        log.info("Order {} expired due to processing timeout", order.getId());
    }
}
```

### 2.7 OrderRepository Update

**File:** `src/main/java/com/gpustore/order/OrderRepository.java`
**Action:** ADD new query method

```java
/**
 * Finds orders with a specific status that haven't been updated since the cutoff time.
 * Used by the expiration job to find stale PROCESSING orders.
 *
 * @param status the order status to filter by
 * @param cutoff orders with updatedAt before this time are returned
 * @return list of stale orders
 */
@Query("SELECT o FROM Order o LEFT JOIN FETCH o.user WHERE o.status = :status AND o.updatedAt < :cutoff")
List<Order> findByStatusAndUpdatedAtBefore(@Param("status") OrderStatus status,
                                            @Param("cutoff") LocalDateTime cutoff);
```

Add import:
```java
import org.springframework.data.repository.query.Param;
import java.time.LocalDateTime;
```

### 2.8 Integration Tests

**File:** `src/test/java/com/gpustore/notification/NotificationServiceIT.java`

```java
package com.gpustore.notification;

import com.gpustore.AbstractIntegrationTest;
import com.gpustore.config.RabbitMqConfig;
import com.gpustore.event.OrderCompletedEvent;
import com.gpustore.event.OrderExpiredEvent;
import com.gpustore.order.Order;
import com.gpustore.order.OrderRepository;
import com.gpustore.order.OrderStatus;
import com.gpustore.user.User;
import com.gpustore.user.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;

class NotificationServiceIT extends AbstractIntegrationTest {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private OrderRepository orderRepository;

    private User testUser;
    private Order testOrder;

    @BeforeEach
    void setUp() {
        notificationRepository.deleteAll();
        orderRepository.deleteAll();
        userRepository.deleteAll();

        // Create test user and order
        testUser = new User("Test User", "notification-test@example.com", "password");
        testUser = userRepository.save(testUser);

        testOrder = new Order(testUser, new BigDecimal("100.00"), OrderStatus.PROCESSING);
        testOrder = orderRepository.save(testOrder);
    }

    @Test
    void handleOrderCompleted_shouldCreateEmailNotification() {
        // Given
        OrderCompletedEvent event = new OrderCompletedEvent(
                testOrder.getId(),
                testUser.getId(),
                testOrder.getTotal(),
                LocalDateTime.now()
        );

        // When
        rabbitTemplate.convertAndSend(
                RabbitMqConfig.EXCHANGE_NAME,
                RabbitMqConfig.ROUTING_KEY_COMPLETED,
                event
        );

        // Then
        await().atMost(5, TimeUnit.SECONDS)
                .until(() -> !notificationRepository.findByOrderId(testOrder.getId()).isEmpty());

        List<Notification> notifications = notificationRepository.findByOrderId(testOrder.getId());
        assertThat(notifications).hasSize(1);
        assertThat(notifications.get(0).getType()).isEqualTo(NotificationType.EMAIL);
        assertThat(notifications.get(0).getMessage()).contains("completed successfully");
    }

    @Test
    void handleOrderExpired_shouldCreateSystemAlertNotification() {
        // Given
        OrderExpiredEvent event = new OrderExpiredEvent(
                testOrder.getId(),
                testUser.getId(),
                "Processing timeout",
                LocalDateTime.now()
        );

        // When
        rabbitTemplate.convertAndSend(
                RabbitMqConfig.EXCHANGE_NAME,
                RabbitMqConfig.ROUTING_KEY_EXPIRED,
                event
        );

        // Then
        await().atMost(5, TimeUnit.SECONDS)
                .until(() -> !notificationRepository.findByOrderId(testOrder.getId()).isEmpty());

        List<Notification> notifications = notificationRepository.findByOrderId(testOrder.getId());
        assertThat(notifications).hasSize(1);
        assertThat(notifications.get(0).getType()).isEqualTo(NotificationType.SYSTEM_ALERT);
        assertThat(notifications.get(0).getMessage()).contains("expired");
    }
}
```

**File:** `src/test/java/com/gpustore/order/OrderExpirationJobIT.java`

```java
package com.gpustore.order;

import com.gpustore.AbstractIntegrationTest;
import com.gpustore.notification.NotificationRepository;
import com.gpustore.notification.NotificationType;
import com.gpustore.user.User;
import com.gpustore.user.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.util.ReflectionTestUtils;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;

class OrderExpirationJobIT extends AbstractIntegrationTest {

    @Autowired
    private OrderExpirationJob orderExpirationJob;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    private User testUser;

    @BeforeEach
    void setUp() {
        notificationRepository.deleteAll();
        orderRepository.deleteAll();
        userRepository.deleteAll();

        testUser = new User("Test User", "expiration-test@example.com", "password");
        testUser = userRepository.save(testUser);
    }

    @Test
    void expireStaleOrders_shouldExpireProcessingOrdersOlderThan10Minutes() {
        // Given - order in PROCESSING state with old updatedAt
        Order staleOrder = new Order(testUser, new BigDecimal("100.00"), OrderStatus.PROCESSING);
        staleOrder = orderRepository.save(staleOrder);

        // Manually set updatedAt to 11 minutes ago
        LocalDateTime elevenMinutesAgo = LocalDateTime.now().minusMinutes(11);
        orderRepository.flush();
        // Use native query or direct update to set updatedAt
        ReflectionTestUtils.setField(staleOrder, "updatedAt", elevenMinutesAgo);
        orderRepository.saveAndFlush(staleOrder);

        // When
        orderExpirationJob.expireStaleOrders();

        // Then
        await().atMost(5, TimeUnit.SECONDS)
                .until(() -> {
                    Order reloaded = orderRepository.findById(staleOrder.getId()).orElseThrow();
                    return reloaded.getStatus() == OrderStatus.EXPIRED;
                });

        // Verify notification was created
        await().atMost(5, TimeUnit.SECONDS)
                .until(() -> !notificationRepository.findByOrderId(staleOrder.getId()).isEmpty());

        assertThat(notificationRepository.findByOrderId(staleOrder.getId()))
                .anyMatch(n -> n.getType() == NotificationType.SYSTEM_ALERT);
    }

    @Test
    void expireStaleOrders_shouldNotExpireRecentProcessingOrders() {
        // Given - recent order in PROCESSING state
        Order recentOrder = new Order(testUser, new BigDecimal("100.00"), OrderStatus.PROCESSING);
        recentOrder = orderRepository.save(recentOrder);

        // When
        orderExpirationJob.expireStaleOrders();

        // Then - order should still be PROCESSING
        Order reloaded = orderRepository.findById(recentOrder.getId()).orElseThrow();
        assertThat(reloaded.getStatus()).isEqualTo(OrderStatus.PROCESSING);
    }

    @Test
    void expireStaleOrders_shouldNotExpirePendingOrders() {
        // Given - old PENDING order
        Order pendingOrder = new Order(testUser, new BigDecimal("100.00"), OrderStatus.PENDING);
        pendingOrder = orderRepository.save(pendingOrder);

        // Manually set updatedAt to 11 minutes ago
        ReflectionTestUtils.setField(pendingOrder, "updatedAt", LocalDateTime.now().minusMinutes(11));
        orderRepository.saveAndFlush(pendingOrder);

        // When
        orderExpirationJob.expireStaleOrders();

        // Then - PENDING orders should not be affected
        Order reloaded = orderRepository.findById(pendingOrder.getId()).orElseThrow();
        assertThat(reloaded.getStatus()).isEqualTo(OrderStatus.PENDING);
    }
}
```

---

## 3. Validation Gates

### Gate 1: Migration
```bash
./mvnw flyway:migrate
```
**Expected:** V3 migration applied successfully

### Gate 2: Compilation
```bash
./mvnw clean compile
```
**Expected:** BUILD SUCCESS

### Gate 3: Full Tests
```bash
./mvnw clean verify
```
**Expected:** All tests pass including NotificationServiceIT and OrderExpirationJobIT

### Gate 4: Manual Verification
```sql
-- Connect to database and verify
SELECT * FROM notifications;
SELECT * FROM orders WHERE status = 'EXPIRED';
```

---

## 4. Dependencies

- **Depends on Part 1:** Event infrastructure, RabbitMQ config, EventBus
- **Required by Part 3:** Frontend needs notification/order data endpoints

---

## 5. Summary

**Part 2 delivers:**
- Notifications table with audit trail
- NotificationService listening to completed/expired events
- Scheduled job expiring stale orders (>10 min in PROCESSING)
- Full test coverage with Testcontainers

**Files created/modified:** 9
